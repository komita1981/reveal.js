<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Testimony</title>

		<meta name="description" content="A short guide how to test your Laravel 4 application">
		<meta name="author" content="Milan Popovic">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/presentation/testimony.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
                    <p class="left_align">
                        What is main property of bad code?
                    </p>
                    <h2 class="fragment">
                        <span class="red_text">
                            It's untestable
                        </span>
                    </h2>
                </section>
                <section>
                    <h2>Kent Beck's rules of simple code</h2>

                    <ul>
                        <ol>
                            1. Runs all the tests
                        </ol>
                        <ol>
                            2. Contains no duplication
                        </ol>
                        <ol>
                            3. Express the intent of programmer
                        </ol>
                        <ol>
                            4. Minimizes the number of classes and methods
                        </ol>
                    </ul>

                    <p class="fragment red_text">
                        Given in order of importance
                    </p>
                </section>
				<section>
					<h1>Testimony</h1>
					<p>
						<small>Presented by <a href="http://milanpopovic.me">Milan Popović</a> / <a href="http://twitter.com/komita1981">@komita1981</a></small>
					</p>
				</section>

                <section>
                    <h2>Me</h2>
                    <p class="left_align">
                        PHP developer
                    </p>
                    <p class="left_align">
                        Work for Nano Interactive
                    </p>
                    <p class="left_align">
                        I like to learn and share knowledge
                    </p>
                    <p class="left_align">
                        Active member of PHP Srbija
                    </p>
                </section>

                <section>
                    <h2>What is testing?</h2>
                    <p class="fragment">
                        Testing is the activity of finding out whether a piece of code produces the intended behavior
                    </p>
                </section>

                <section>
                    <section>
                        <h2>What do people think about testing?</h2>
                    </section>

                    <section>
                        <img class="noframes" src="img/testimony/i-dont-always-test-my-code.jpg">
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/testimony/code_without_tests.jpeg">
                        </p>
                        <aside class="notes">
                            Time consuming - Who has time to write tests???
                        </aside>
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/testimony/hard-work.jpg" height="600px" width="790px">
                        </p>
                        <aside class="notes">
                            Testing is hard
                        </aside>
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/testimony/steep_learning_curve.jpg">
                        </p>
                        <aside class="notes">
                            Steep learning curve
                        </aside>
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/testimony/no-money.jpg">
                        </p>
                        <aside class="notes">
                            Don’t make anybody any money
                        </aside>
                    </section>

                    <section>
                        <p class="left_align">
                            Time consuming
                        </p>
                        <p class="left_align">
                            Testing is hard
                        </p>
                        <p class="left_align">
                            Steep learning curve
                        </p>
                        <p class="left_align">
                            Don’t make anybody any money
                        </p>
                    </section>
                </section>

                <section>
                    <h2>What testing really is?</h2>

                    <p class="fragment left_align">
                        Prove you've done your work
                    </p>

                    <p class="fragment left_align">
                        Reduce number of bugs
                    </p>

                    <p class="fragment left_align">
                        Facilitate change
                    </p>

                    <p class="fragment left_align">
                        Help you make better code design - easier to maintain
                    </p>

                    <p class="fragment left_align">
                        Ensures stable, long lasting application
                    </p>

                    <p class="fragment left_align">
                        Improve understanding how clients are going to use your code
                    </p>

                    <p class="fragment left_align">
                        Enhance security
                    </p>

                    <p class="fragment left_align">
                        Provide free documentation
                    </p>

                    <aside class="notes">
                        Prove you've done your work - Help you check much faster if you're work is done. Testing is an
                        insurance that the system works.

                        Facilitates change - protect you from breaking things - guard from regression bugs. Let you apply
                        changes with less worries - refactoring will improve things without breaking anything.

                        Reduce number of bugs - Having a bug in the code means carrying a
                        risk. Utilising a set of unit tests, engineers can dramatically reduce number of bugs and the
                        risk with untested code - It better for you that you find your bugs than your client.
                    </aside>
                </section>
                <section>
                    <h2>Automated testing</h2>
                    <p class="red_text left_align">
                        When I say testing I mean AUTOMATED testing
                    </p>
                    <p class="left_align">
                        Manual testing is time consuming and boring
                    </p>
                    <p class="left_align">
                        Automated testing is fun and a key point for software quality
                    </p>
                </section>

                <section>
                    <section>
                        <h2>Test types</h2>
                        <p class="fragment">
                            Acceptance (end-to-end)<br/>
                            Test as if end user would use the whole system/feature
                        </p>
                        <p class="fragment">
                            Integration<br/>
                            Test how different parts of system work together
                        </p>
                        <p class="fragment">
                            Unit<br/>
                            Test single unit of code - mock all dependencies
                        </p>
                        <aside class="notes">
                            Good ideas often fail in practice, and in the world of testing, one pervasive good idea that
                            often fails in practice is a testing strategy built around end-to-end tests.

                            Unit tests do have one major disadvantage: even if the units work well in isolation, you do
                            not know if they work well together. But even then, you do not necessarily need end-to-end
                            tests. For that, you can use an integration test. An integration test takes a small group
                            of units, often two units, and tests their behavior as a whole, verifying that they
                            coherently work together. If two units do not integrate properly, why write an end-to-end
                            test when you can write a much smaller, more focused integration test that will detect the
                            same bug? While you do need to think larger, you only need to think a little larger to
                            verify that units work together.
                        </aside>
                    </section>
                    <section>
                        <img class="noframes" src="img/testimony/testing_pyramid.png">
                        <aside class="notes">
                            Width = Number of tests
                            The bulk of your tests are unit tests at the bottom of the pyramid. As you move up the
                            pyramid, your tests gets larger, but at the same time the number of tests (the width of your
                            pyramid) gets smaller.
                        </aside>
                    </section>
                    <section>
                        <h2>Google team suggest</h2>
                        <ul>
                            <li>
                                E2E - 10 %
                            </li>
                            <li>
                                Integration - 20%
                            </li>
                            <li>
                                Unit - 70%
                            </li>
                        </ul>
                        <aside class="notes">
                            As a good first guess, Google often suggests a 70/20/10 split:
                            70% unit tests, 20% integration tests, and 10% end-to-end tests. The exact mix will be
                            different for each team, but in general, it should retain that pyramid shape
                        </aside>
                    </section>
                    <section>
                        <h2>Testing anti-patterns</h2>
                    </section>
                    <section>
                            <img class="noframes" src="img/testimony/testing_inverted_pyramid.png">
                            <p>Inverted pyramid/ice cream cone</p>
                        <aside class="notes">
                            Inverted pyramid - The team relies primarily on end-to-end tests, using few integration
                            tests and even fewer unit tests.
                        </aside>
                    </section>
                    <section>
                            <img class="noframes" src="img/testimony/testing_hourglass.png">
                            <p>Hourglass</p>
                        <aside class="notes">
                            Hourglass. The team starts with a lot of unit tests, then uses end-to-end tests where
                            integration tests should be used. The hourglass has many unit tests at the bottom and many
                            end-to-end tests at the top, but few integration tests in the middle.
                        </aside>
                    </section>
                </section>

                <section>
                    <h2>
                        What is unit testing?
                    </h2>
                    <p class="fragment left_align">
                        A software testing method to test individual unit of source code - a method in class or a piece of code
                    </p>
                    <p class="fragment left_align">
                        The purpose of unit testing is not for finding bugs
                    </p>
                    <p class="fragment left_align">
                        Specification for the expected behaviours of the code under test
                    </p>
                    <aside class="notes">
                        When writing unit tests we are focusing on describing one unit of behaviour at a time, and how
                        objects communicate in order to achieve that behaviour.

                        Each unit test sends a specific input to a method and verifies that the method returns the
                        expected value, or takes the expected action. Unit tests prove that the code you are testing
                        does in fact do what you expect it to do.

                        The purpose of unit testing is not for finding bugs. It’s a specification for the expected
                        behaviours of the code under test. The code under test is the implementation for those expected
                        behaviours. So unit test and the code under test are used to check the correctness of each other,
                        and protect each other. Later when someone changed the code under test, and it changed the
                        behaviour that is expected by the original author, the test will fail. If you code is covered by
                        reasonable unit test, you can maintain the code without breaking the existing feature.
                        That’s why Michael Feathers define legacy code as code without unit test.
                    </aside>
                </section>

                <section>
                    <p>
                        What is to be tested?
                    </p>
                    <h2 class="fragment">
                        <span class="red_text">
                            EVERYTHING
                        </span>
                    </h2>
                    <p class="fragment">
                        To be more precise
                    </p>
                    <h2 class="fragment">
                        <span class="red_text">
                            EVERYTHING THAT COULD BREAK YOUR APP
                        </span>
                    </h2>
                </section>

                <section>
                    <h2>
                        What does not need to be tested?
                    </h2>
                    <p class="fragment left_align">
                        Getters/Setters
                    </p>
                    <p class="fragment left_align">
                        Framework
                    </p>
                    <p class="fragment left_align">
                        Third party packages
                    </p>
                    <p class="fragment left_align">
                        Protected & private methods and properties
                    </p>

                    <aside class="notes">
                        Just because the testing of protected and private attributes and methods is possible does not
                        mean that this is a "good thing".

                        "In general, you don't want to break any encapsulation for the sake of testing (or as Mom used
                        to say, "don't expose your privates!"). Most of the time, you should be able to test a class by
                        exercising its public methods. If there is significant functionality that is hidden behind
                        private or protected access, that might be a warning sign that there's another class in there
                        struggling to get out."
                        You shouldn’t test private methods and private properties because doing so will cause your unit
                        tests to become a barrier to refactoring. If you ever do find yourself compelled to test a
                        private or protected method, this is probably a strong indication that the method should be
                        refactored in to its own stand-alone class.
                    </aside>
                </section>

                <section>
                    <h2>
                        Unit testing FIRST principles
                    </h2>
                    <p class="left_align">
                        <span class="red_text">F</span>ast - Be fast or be dead
                    </p>
                    <p class="left_align">
                        <span class="red_text">I</span>ndependent/Isolated - Run without dependency
                    </p>
                    <p class="left_align">
                        <span class="red_text">R</span>epeatable - Should be idempotent
                    </p>
                    <p class="left_align">
                        <span class="red_text">S</span>elf-verifying - Just pass or fail
                    </p>
                    <p class="left_align">
                        <span class="red_text">T</span>imely - Write test before production
                    </p>
                    <aside class="notes">
                        Fast - if tests are slow you wont run them frequently, you will start to avoid using it and you
                        will rot your code. A developer should not hesitate to run the tests as they are slow.
                        If developer hesitates to run the tests after a simple one-liner change tests are far too slow.
                        Make the tests so fast you don't have to consider them. The faster your tests run, the more often
                        you’ll run them. All of these including setup, the actual test and tear down should execute really fast
                        (milliseconds) as you may have thousands of tests in your entire project. Unit tests save you time
                        by finding errors immediately after you make them.

                        Independent - A unit test is a small automated test, coded by a programmer, that verifies
                        whether or not a small piece of production code—a unit—works as expected in isolation. A real
                        unit test verifies the behavior of a single code unit isolated from its dependencies. Each unit
                        test should have a single reason to fail.
                        You must design your tests to be independent not only of external factors, but of each other as
                        well. When tests are interdependent, a change to one test can cause several others to fail in
                        puzzling ways. Ordering unit tests to optimize their execution is a sign that isolation is poor.
                        Test should not depend on each other, no matter in which order you run them - they
                        should always pass. Tests must not have any order-of-run dependency. They should pass or fail
                        the same way in suite or when run individually. Each suite should be re-runnable (every minute
                        or so) even if tests are renamed or reordered randomly. Good tests interferes with no other
                        tests in any way. They impose their initial state without aid from other tests. They clean up
                        after themselves.

                        Repeatable - You should obtain the same results every time you run a test. No matter in
                        environment you run your tests - they should pass - no excuses. If they are not - you have
                        problem. They should pass on all machines. If they are not repeatable
                        you will always have an excuse. A test method should NOT depend on any data in the
                        environment/instance in which it is running. Each test should setup or arrange it's own data.
                        What if a set of tests need some common data? Use Data Helper classes that can setup this data
                        for re-usability.

                        Self validating -  A good unit test fails or passes unambiguously. When all tests run green, you
                        have high confidence that you can ship the code to the next level (likely the acceptance test
                        automated suite). If any of the tests fail, you don’t proceed until they get fixed. The
                        pass/fail nature of the automated testing system makes it viable even for large teams. When a
                        test suite leaves some results open to human interpretation, validating them becomes a drag on
                        the productivity of all programmers. Ambiguous tests fail to be helpful and fall into disuse.
                        That means - no manual inspection required to check whether the test has passed or failed.
                        You should do everything automatically. Test should have boolean output - pass or fail.
                        Funny fact - Do programmers really write unit tests that test nothing? Sadly, yes. A recent SD
                        Times article related this story: “One organization outsourced its test case implementation with
                        the goal of achieving 80% test coverage. The test coverage went up, but because the tests were
                        calling methods but not validating them, the outcome was useless.” (Morgan, Lisa. “Driving Higher
                        Value from Build Management and Continuous Integration,” SD Times, October 2011.)

                        Timely - There is one good time when you have to write your tests - just before production code
                        Writing tests before the code encourages you to think of the use of the code before you think of
                        its implementation. The tests are the very first client of the code you’re building. A clean
                        unit test should make it very clear what the client code will look like. Hopefully you’ll do
                        things like improve your function names and design simpler parameter lists as a result.
                    </aside>
                </section>

                <section>
                    <h2>
                        Write unit tests before or after code?
                    </h2>
                    <p class="fragment left_align">
                        After - You test what you code - Test Last <br/>
                        Development Driven Testing - <span class="red_text">DDT</span>
                    </p>
                    <p class="fragment left_align">
                        Before - You code what you test - Test First<br/>
                        Test Driven Development - <span class="red_text">TDD</span>
                    </p>

                </section>

                <section>
                    <img class="noframes" src="img/testimony/ddt_circle_of_life.png">

                    <aside class="notes">
                        Test Last = Test-After Development (TAD)
                        TAD programmers want to verify their code, too, but they typically have little interest in
                        treating the tests as “specifications by example.” For them, the usually singular goal of unit
                        testing is to verify whether or not some aspects of the code work. These unit tests typically
                        cover up to two-thirds of the code base. Other forms of integration tests can increase effective
                        coverage, but unit tests are the closest reliable documentation for the code you’re modifying.
                        The real sticking point with TAD is productivity. When you don’t think about how to craft code
                        so it’s testable, you’ll often end up with code that is near-impossible to test. The test-writer
                        has to either rework it or use a lot of finesse to avoid rework. This makes testing feel like a
                        waste of time. No wonder so few programmers have fully embraced unit-testing! We find TAD to be
                        simply less fun, less beneficial, less productive, and more frustrating than TDD.
                    </aside>

                </section>

                <section>
                    <h2>
                        The Three Laws of TDD
                    </h2>

                    <ol>
                        <li>
                            You may not write production code until you have written a failing unit test
                        </li>
                        <li>
                            You may not write more of a unit test than is sufficient to fail
                        </li>
                        <li>
                            You may not write more production code than is sufficient to pass the currently failing
                            test
                        </li>
                    </ol>
                </section>

                <section>
                    <img class="noframes" src="img/testimony/tdd_circle_of_life.png">

                    <aside class="notes">
                        Only write code if you absolutely have to and always know what your code is supposed to do before
                        you start writing it - and that is what TDD approach provides for you

                        “Red-Green-Refactor,” meaning that you start with a failing test, then pass it, and then make
                        your code readable and more maintainable.
                    </aside>
                </section>

                <section>
                    <p>
                        <img class="noframes" src="img/testimony/test_statistics.png">
                    </p>
                    <p>
                        IBM & Microsoft - TDD -  20-40% longer to complete but 40-90% fewer bugs in production
                    </p>
                </section>

                <section>
                    <blockquote>
                        By 2022 it will be not be possible to get a professional programming job if you do not practice
                        TDD routinely - Allan Kelly
                    </blockquote>
                </section>

                <section>
                    <section>
                        <p>
                            <img class="noframes" src="img/testimony/phpunit.png">
                        </p>

                    </section>
                    <section>
                        <p class="left_align">
                            Member of xUnit family
                        </p>

                        <p class="left_align">
                            Created by Sebastian Bergmann and contributors
                        </p>

                        <p class="left_align">
                            Integrated/Supported by all modern frameworks
                        </p>

                        <p class="left_align">
                            Integrated in most IDE (PHPStorm, Netbeans, Eclipse, ZS)
                        </p>

                        <p class="left_align">
                            Written for PHP 5.x
                        </p>

                        <p class="left_align">
                            Install using composer or phar

                    <pre><code data-trim contenteditable>
"require-dev": {
    "phpunit/phpunit": "4.*"
},
                    </code></pre>
                        </p>
                        <p class="left_align red_text">
                            PEAR install - not supported from 1.1.2015
                        </p>
                    </section>


                    <section>
                        <h2>xUnit architecture</h2>
                        <ol>
                            <li>
                                Test runner
                            </li>
                            <li>
                                Test case
                            </li>
                            <li>
                                Test fixtures
                            </li>
                            <li>
                                Test suites
                            </li>
                            <li>
                                Test executions
                            </li>
                            <li>
                                Test result formatter
                            </li>
                            <li>
                                Assertions
                            </li>
                        </ol>
                        <aside class="notes">
                            XUnit is the family name given to bunch of testing frameworks that have become widely known
                            amongst software developers. The name is a derivation of JUnit, the first of these to be
                            widely known. The origins of these frameworks actually started in Smalltalk. Kent Beck was
                            a big fan of automated testing at the heart of software development. To help him, and his
                            clients, do this he would build a simple framework to organize and run unit tests. The focus
                            was on making it easy for programmers to define the tests using their regular smalltalk
                            environment, and then to run either a subset or a full set of tests quickly. Kent and his
                            followers would run unit tests after every change to the system going through a rapid edit
                            and test cycle in the Smalltalk IDE.
                        </aside>
                    </section>
                    <section>
                        <h2>
                            1. Test runner
                        </h2>
                        <p class="left_align">
                            Executable program that runs tests implemented using an xUnit framework and reports the
                            test results
                        </p>
                        <p class="left_align">
                            PhpUnit - phpunit/phpunit/phpunit file
                        </p>
                    </section>
                    <section>
                        <h2>
                            2. Test case
                        </h2>
                        <p class="left_align">
                            The most elemental class
                        </p>
                        <p class="left_align">
                            All unit tests are inherited from this class
                        </p>
                        <p class="left_align">
                            PhpUnit - PHPUnit_Framework_TestCase class
                        </p>
                    </section>

                    <section>
                        <h2>
                            3. Test fixtures
                        </h2>
                        <p class="left_align">
                            Set of preconditions or state needed to run a test
                        </p>
                        <p class="left_align">
                            Known good state should be set up before the tests, and return to the original state after
                            the tests
                        </p>
                        <p class="left_align">
                            PhpUnit - setUp(), tearDown(), setUpBeforeClass() and tearDownAfterClass() methods
                        </p>
                        <pre><code data-trim contenteditable>
protected function setUp()
{
    // preconditions or DRY code
}
protected function tearDown()
{
    // clear all after tests
}
                        </code></pre>
                    </section>

                    <section>
                        <h2>
                            4. Test suites
                        </h2>
                        <p class="left_align">
                            Set of tests that all share the same fixture
                        </p>
                        <p class="left_align">
                            PhpUnit - testsuites options in phpunit.xml
                        </p>
                        <pre><code data-trim contenteditable>
// part of phpunit.xml file
<testsuite name="Unit">
    <directory>./app/tests/Unit/</directory>
</testsuite>

// from the command line
phpunit --testsuite Unit
                        </code></pre>
                    </section>

                    <section>
                        <h2>
                            5. Test execution
                        </h2>
                        <pre><code data-trim contenteditable>
setUp();
...
/* Body of test - Tested class - System Under Tests */
...
tearDown(); */
                        </code></pre>
                    </section>

                    <section>
                        <h2>
                            6. Test result formatter
                        </h2>
                        <p class="left_align">
                            Produces results in one or more output formats
                        </p>
                        <p class="left_align">
                            PhpUnit test results:
                        </p>
                        <p class="left_align">
                            . - Test succeeds
                        </p>
                        <p class="left_align">
                            F - Assertion fails while running the test method
                        </p>
                        <p class="left_align">
                            E - Error occurs while running the test method
                        </p>
                        <p class="left_align">
                            R - Test has been marked as risky
                        </p>
                        <p class="left_align">
                            S - Test has been skipped
                        </p>
                        <p class="left_align">
                            I - Test is marked as being incomplete or not yet implemented
                        </p>
                    </section>

                    <section>
                        <h2>
                            7. Assertions
                        </h2>

                        <p class="left_align">
                            Function that verifies the behavior (or the state) of the unit under test
                        </p>

                        <p class="left_align">
                            Usually result is bool
                        </p>

                        <p class="left_align">
                            PhpUnit examples
                        </p>

                        <p class="left_align">
                            <span class="red_text">assertTrue</span> - Check the input to verify it equals true
                        </p>

                        <p class="left_align">
                            <span class="red_text">assertFalse</span> - Check the input to verify it equals false
                        </p>

                        <p class="left_align">
                            <span class="red_text">assertEquals</span> - Check the result against another input for a match
                        </p>

                        <p class="left_align">
                            <span class="red_text">assertContains</span> - Check that the input contains a certain value
                        </p>

                        <p class="left_align">
                            Many more asserts - official documentation...
                        </p>
                    </section>

                    <section>
                        <h2 class="cc_logo_fix_50">
                            PHPUnit's test goals
                        </h2>

                        <p class="left_align">
                            Easy to learn to write
                        </p>

                        <p class="left_align">
                            Easy to write
                        </p>

                        <p class="left_align">
                            Easy to read
                        </p>

                        <p class="left_align">
                            Easy to execute
                        </p>

                        <p class="left_align">
                            Quick to execute
                        </p>

                        <p class="left_align">
                            Isolated
                        </p>

                        <p class="left_align">
                            Composable
                        </p>

                    </section>

                    <section>
                        <h2>
                            Test config
                        </h2>
                        <p class="left_align">
                            Configured in <span class="red_text">phpunit.xml</span>  file
                        </p>

                        <pre><code data-trim contenteditable>
<phpunit bootstrap="bootstrap/autoload.php"

         backupGlobals="false"

         backupStaticAttributes="false"

         colors="true"

         convertErrorsToExceptions="true"

         convertNoticesToExceptions="true"

         convertWarningsToExceptions="true"

         processIsolation="false"

         stopOnFailure="false"

         syntaxCheck="false"
        >
    <testsuites>
        <testsuite name="Unit">
            <directory>./app/tests/Unit/</directory>
        </testsuite>
        <testsuite name="Integration">
            <directory>./app/tests/Integration/</directory>
        </testsuite>
    </testsuites>
</phpunit>
                        </code></pre>

                    </section>
                    <section>
                        <p class="left_align">
                            Bootstrap example (Laravel)
                        </p>
                        <p class="left_align">
                            Runs before all tests
                        </p>
                        <pre><code data-trim contenteditable>
require __DIR__.'/vendor/autoload.php';

date_default_timezone_set('UTC');
Carbon\Carbon::setTestNow(Carbon\Carbon::now());
                        </code></pre>
                    </section>

                    <section>
                        <img class="noframes" src="img/testimony/phpunit_directory_structure.jpg">
                    </section>
                    <section>
                        <h2>
                            Test structure
                        </h2>

                        <p class="left_align">
                            The tests for a class <span class="red_text">Class</span> go into a class <span class="red_text">ClassTest</span>
                        </p>

                        <p class="left_align">
                            <span class="red_text">ClassTest</span> inherits from <span class="red_text">PHPUnit_Framework_TestCase</span>
                        </p>

                        <p class="left_align">
                            The tests are public methods that are named <span class="red_text">test*</span>
                        </p>

                        <p class="left_align">
                            Inside the test methods assertion methods are used - <span class="red_text">assert*</span>
                        </p>

                    </section>

                    <section>
                        <p class="left_align">
                            PhpUnit test example (Laravel ConsoleScheduledEventTest)
                        </p>
                        <pre><code data-trim contenteditable>
// Some parts of code removed intentionaly
class ConsoleScheduledEventTest extends PHPUnit_Framework_TestCase
{
/**
    * The default configuration timezone.
    *
    * @var string
    */
    protected $defaultTimezone;

    public function setUp()
    {
        $this->defaultTimezone = date_default_timezone_get();
        date_default_timezone_set('UTC');
    }

    public function tearDown()
    {
        date_default_timezone_set($this->defaultTimezone);
        Carbon::setTestNow(null);
        m::close();
    }

    public function testEventIsDueCheck()
    {
        $app = m::mock('Illuminate\Foundation\Application[isDownForMaintenance,environment]');
        $app->shouldReceive('isDownForMaintenance')->andReturn(false);
        $app->shouldReceive('environment')->andReturn('production');
        Carbon::setTestNow(Carbon::create(2015, 1, 1, 0, 0, 0));

        $event = new Event('php foo');
        $this->assertEquals('* * * * 4 *', $event->thursdays()->getExpression());
        $this->assertTrue($event->isDue($app));

        $event = new Event('php foo');
        $this->assertEquals('0 19 * * 3 *', $event->wednesdays()->at('19:00')->timezone('EST')->getExpression());
        $this->assertTrue($event->isDue($app));
    }
}
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Testing doubles</h2>
                        <ul>
                            <li class="left_align">Dummy</li>
                            <li class="left_align">Fake</li>
                            <li class="left_align">Stub</li>
                            <li class="left_align">Mock</li>
                            <li class="left_align">Spy</li>
                        </ul>
                        <aside class="notes">
                            Test doubles are a way of replacing all classes in our tests other than the one we are
                            testing. They give us control on direct and indirect outputs that would have been generated
                            by those classes. Understanding the role of the test double helps us to write better tests,
                            and thus better code. If we manage to isolate the “collaborators” (the other objects
                            involved in our test) using doubles and test our objects in isolation, then we have achieved
                            modularity: our code is decoupled and the communication between objects is documented by our
                            tests.
                        </aside>
                    </section>

                    <section>
                        <h2>Generation doubles doubles</h2>
                        <ul>
                            <li>phpunit/phpunit-mock-object</li>
                            <li>phpspec/prophecy</li>
                            <li>mockery/mockery</li>
                            <li>phake/phake</li>
                            <li>codeception/aspect-mock</li>
                            <li>php-vci/php-vci</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Prophecy</h2>
                        <p class="left_align">
                            Highly opinionated mocking framework for PHP 5.3+
                        </p>
                        <p class="left_align">
                            Created by Konstantin Kudryashov and contributors
                        </p>
                        <p class="left_align">
                            Initially it was created to fulfil phpspec2 needs
                        </p>
                        <p class="left_align">
                            From version 4.5 PHPUnit is the out-of-the-box support for Prophecy
                        </p>
                        <p class="left_align">
                            Developers will be encouraged to use Prophecy instead of the PHPUnit mocks
                        </p>
                        <p class="left_align">
                            Composer install
                            <pre><code data-trim contenteditable>
"require-dev": {
    "phpspec/prophecy": "~1.0"
},
                            </code></pre>
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            Every word has a logical meaning, even the name of the library itself (Prophecy)
                        </p>
                        <blockquote cite="https://github.com/phpspec/prophecy">
                            &ldquo;Prophecy has been named that way because it concentrates on describing the future
                            behavior of objects with very limited knowledge about them. But as with any other prophecy,
                            those object prophecies can't create themselves - there should be a Prophet&rdquo;
                        </blockquote>

                        <p>
                            <pre><code data-trim contenteditable>
$prophet = new Prophecy\Prophet;
                            </code></pre>
                        </p>
                    </section>

                    <section>
                        <blockquote cite="http://thephp.cc/news/2015/02/phpunit-4-5-and-prophecy">
                            &ldquo;The prophet creates prophecies by prophesizing them. Test double objects are then
                            created by revealing their respective prophecy. You can think of a prophecy as the
                            configuration for a test double that is stored in an object separate from the object
                            (revelation) that acts as the test double.&rdquo;
                        </blockquote>
                        <p class="fragment">
                            <span class="red_text">
                                Confused?
                            </span>
                        </p>
                        <p class="fragment">
                            Show me some examples
                        </p>
                    </section>
                    <section>
                        <h2>Dummy</h2>
                        <p class="left_align">
                            Objects are passed around but never actually used
                        </p>
                        <p class="left_align">
                            Passed around for typehinting
                        </p>
                        <p class="left_align">
                            No behaviour
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
class CustomerCardPrinter
{
    private $printer;
    private $customer;

    public function __construct(PrinterInterface $printer, CustomerInterface $customer)
    {
        $this->printer = $printer;
        $this->customer = $customer;
    }

    public function print()
    {
        if (! $this->printer->isAvailable()){
            return false;
        }
        $customerName = $customer->getName();
        // some code goes here
    }
}

class CustomerCardPrinterTest
{
    public function testPrinterNotAvailable()
    {
        $printerProphet = $this->prophesize('\SomeNamespace\SomePackage\PrinterInterface');
        $printerProphet->isAvailable()->willReturn(false);

        $dummyCustomerProphet = $this->prophesize('\SomeNamespace\SomeOtherPackage\CustomerInterface');

        $customerCardPrinter = new CustomerCardPrinter($someDriverProphet->reveal(), $dummyPrinterProphet->reveal());

        $printResult = $customerCardPrinter->print();

        $this->assertFalse($expectedResult, $testResult);
    }
}
                        </code></pre>
                    </section>

                    <section>
                        <h2>Fake</h2>
                        <p class="left_align">
                            The output of the method isn’t important
                        </p>
                        <p class="left_align">
                            Prophecy will not tolerate faking a method that hasn’t been declared anywhere
                        </p>
                        <pre><code data-trim contenteditable>
class MarkdownTest extends TestCase
{
    /** @test */
    function it_attaches_default_events()
    {
        $eventDispatcher = $this->prophesize('Markdown\Event\EventDispatcher');
        $eventDispatcher->addListener(Argument::type('Markdown\Event\EndOfLineListener'));
        $markdown = new Markdown($eventDispatcher->reveal());
        // continue with some assertions on $markdown...
    }
}
                        </code></pre>

                    </section>

                    <section>
                        <pre><code data-trim contenteditable>
interface PrinterInterface
{
    public function isAvailable();
}
class Printer implements PrinterInterface
{
    public function isAvailable()
    {
        // some code goes here
    }
}

class FakePrinter implements PrinterInterface
{
    public function isAvailable()
    {
        return true;
    }
}
                        </code></pre>
                    </section>

                    <section>
                        <h2>Stub</h2>
                        <p class="left_align">
                            Has (basic) behaviour but no expectations
                        </p>
                        <p class="left_align">
                            It does not matter how many times a method is called - Doesn't have to be called
                        </p>
                        <p class="left_align">
                            Promises it will always return the same thing (willReturn())
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
class CustomerCardPrinter
{
    private $printer;
    private $customer;

    public function __construct(PrinterInterface $printer, CustomerInterface $customer)
    {
        $this->printer = $printer;
        $this->customer = $customer;
    }

    public function print()
    {
        if (! $this->printer->isAvailable()){
            return false;
        }

        $customerName = $customer->getName();
        // some code goes here
    }
}

class CustomerCardPrinterTest
{
    public function testSuccessfulPrint()
    {
        $printerProphet = $this->prophesize('\SomeNamespace\SomePackage\PrinterInterface');
        $printerProphet->isAvailable()->willReturn(true);

        $dummyCustomerProphet = $this->prophesize('\SomeNamespace\SomeOtherPackage\CustomerInterface');
        $dummyCustomerProphet->getName()->willReturn('SomeName');

        $customerCardPrinter = new CustomerCardPrinter($someDriverProphet->reveal(), $dummyPrinterProphet->reveal());

        $printResult = $customerCardPrinter->print();

        $this->assertTrue($expectedResult, $testResult);
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Mock</h2>
                        <p class="left_align">
                            Define predictions (shouldBeCalled()), not promises
                        </p>
                        <p class="left_align">
                            Describing what will happen in the future
                        </p>
                        <p class="left_align">
                            Keeps track of method calls and their arguments
                        </p>
                        <p class="left_align">
                            Validates method calls given a certain set of expectations
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
class CustomerCardPrinter
{
    private $printer;
    private $customer;

    public function __construct(PrinterInterface $printer, CustomerInterface $customer)
    {
        $this->printer = $printer;
        $this->customer = $customer;
    }

    public function print()
    {
        if (! $this->printer->isAvailable()){
            return false;
        }

        $customerName = $customer->getName();
        // some code goes here
    }
}

class CustomerCardPrinterTest
{
    public function testSuccessfulPrint()
    {
        $printerProphet = $this->prophesize('\SomeNamespace\SomePackage\PrinterInterface');
        $printerProphet->isAvailable()->shouldBeCalled()->willReturn(true);

        $dummyCustomerProphet = $this->prophesize('\SomeNamespace\SomeOtherPackage\CustomerInterface');
        $dummyCustomerProphet->getName()->shouldBeCalled()->willReturn('SomeName');

        $customerCardPrinter = new CustomerCardPrinter($someDriverProphet->reveal(), $dummyPrinterProphet->reveal());

        $printResult = $customerCardPrinter->print();

        $this->assertTrue($expectedResult, $testResult);
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Spy</h2>
                        <p class="left_align">
                            Records behaviour
                        </p>
                        <p class="left_align">
                            Describing what has happened in the past
                        </p>
                        <p class="left_align">
                            Assertions happen afterwards (shouldHaveBeenCalled())
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
function it_notifies_an_attached_subscriber()
{
    $parser = new ParserSubject;

    $dummyEvent = $this->prophesize('Markdown\Event\Event')->reveal();
    $subscriber = $this->prophesize('Markdown\Parser\Subscriber')->reveal();

    $parser->notify($dummyEvent);

    $subscriber->onChange($dummyEvent)->shouldHaveBeenCalled();
}
                        </code></pre>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>3 A of Unit testing</h2>
                        <p class="left_align">
                            <span class="red_text">A</span>rrange objects, creating and setting them up as necessary.
                        </p>
                        <p class="left_align">
                            <span class="red_text">A</span>ct on an object
                        </p>
                        <p class="left_align">
                            <span class="red_text">A</span>ssert that something is as expected
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            Arrange = Setup
                        </p>
                        <p class="left_align">
                            Act = Poke
                        </p>
                        <p class="left_align">
                            Assert = Verify
                        </p>

                        <aside class="notes">
                            Meszaros adds one more element - teardown (cleanup)
                        </aside>
                    </section>
                    <section>
                    <pre><code data-trim contenteditable>
public function testSuccessful()
{
    // ARRANGE
    $someDriverProphet = $this->prophesize('\SomeNamespace\SomePackage\SomeDriverInterface');
    $someDriverProphet->doSomething()->shouldBeCalled()->willReturn('value');
    $testedClass = new TestedClass($someDriverProphet);

    // ACT
    $testResult = $testedClass->testedMethod();

    // ASSERT
    $this->assertSomething($expectedResult, $testResult);
}
                    </code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>
                            Structuring Unit Tests
                        </h2>
                        <ul>
                            <li>
                                One test class per tested class
                            </li>
                            <li>
                                One test class per method of tested class
                            </li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <img class="noframes" src="img/testimony/advice.jpg">
                    </section>
                    <section>
                        <p class="left_align">
                            1. Try with writing tests after writing the code
                        <p class="left_align">
                    </section>
                    <section>
                        <p class="left_align">
                            2. When you get confidence try to write tests before the code
                        <p class="left_align">
                    </section>
                    <section>
                        <p class="left_align">
                            3. Treat test like your code - keep it "clean"
                        <p class="left_align">
                        <p class="fragment">
                            <ul>
                                <li>
                                    Be descriptive about what you are testing
                                </li>
                                <li>
                                    Do not duplicate test code
                                </li>
                                <li>
                                    Do not make tests complex
                                </li>
                            </ul>
                        </p>
                        <aside class="notes">
                            Tests are clean if they are readable. What make them readable is clarity, simplicity and
                            density of expression - Clean Code - Robert C Martin
                            "What makes a clean test? Three things - Readability, readability, readability
                            Readability is even more important than in production code

                            Keep in mind that testing code is important as production code - maybe more important. It must
                            be clean as production code. Code changes and that means that your tests also changes - if you
                            write them bad than you have big problem - double problem. You are not safe anymore. You will start
                            writing code without tests.

                            Unit tests keep our code flexible, maintainable and reusable. Without them we loose everything.
                            With good tests we can improve architecture and design without having the fear of introducing
                            bugs.
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            4. Number of asserts in a test ought to be minimized
                        </p>
                        <aside class="notes">
                            One assert per test story...
                            Better use Single Concept per Test
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            5. Use Virtual Environments
                        </p>
                        <p class="left_align">
                            <img class="noframes" src="img/testimony/vagrant_docker.png">
                        </p>
                        <aside class="notes">
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            6. Run tests often
                        </p>
                        <aside class="notes">
                            Run all your unit tests as often as possible, ideally every time the code is changed and
                            before any commit. Running tests often gives you confidence that your changes didn't break
                            anything and generally lowers the stress of programming in the dark. For larger systems,
                            you may just run specific test suites that are relevant to the code you're working on. Run
                            all your acceptance, integration, stress, and unit tests at least once per day (or night).
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            7. Test Boundary Conditions
                        </p>
                        <aside class="notes">
                            Take care about testing boundary values
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            8. Use test saboteurs (Humbug project)
                        </p>
                        <aside class="notes">
                            Mutation Testing is, in a nutshell, giving your unit tests a run for their money. It
                            involves injecting small defects into source code and then checking if the unit tests
                            noticed. If they do, then your unit tests have "killed" the mutation. If not, the mutation
                            has escaped detection. As unit tests are intended to prevent regressions, having a real
                            regression pass unnoticed would be a bad thing! Whereas Code Coverage can tell you what code
                            your tests are executing, Mutation Testing is intended to help you judge how well your unit
                            tests actually perform and where they could be improved.
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            9. Use test coverage
                        </p>
                        <p class="left_align">
                            <img class="noframes" src="img/testimony/code-coverage.png">
                        </p>

                        <aside class="notes">
                            The higher code coverage makes your confidence also high - less fear of change
                        </aside>
                    </section>

                    <section>
                        <p class="red_text">
                            Test branch coverage not only code coverage
                        <pre><code data-trim contenteditable>
sampleMethod()
{
    if (a < 5 and b > 10){
       return a + b;
    }

    return $a - $b;
}
                        </code></pre>
                        </p>

                    </section>
                    <section>
                        <p class="left_align">
                            10. Test before refactoring
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            11. Write unit tests for each bug you are going to fix
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            12. Think twice before using New Operators - new ClassName()
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            13. Think twice before using statics - SomeClass::someMethod()
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            14. Avoid endless "anding" - Breaking SRP
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            15. Avoid using switch-case often - use design patterns instead
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            16. Avoid using too many dependencies - max 4 dependencies
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            17. Avoid logic in constructor - only assign variables
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            17. Do not break Law of Demeter
                        </p>
                        <pre><code data-trim contenteditable>
if ($account->getUser()->getRole()->IsAdmin()) {
    return false;
}
                        </code></pre>
                    </section>
                    <section>
                        <p class="left_align">
                           18. Don’t Mock What You Don’t Own
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                           19. Use data providers
                        </p>
                        <pre><code data-trim contenteditable>
/**
* @dataProvider getSuccessfulAddData
*/
public function testSuccessfulAdd($a, $b, $result)
{
    $this->assertEquals($result,
    $this->calculator->add($a, $b));
}

public function getSuccessfulAddData()
{
    return [
        ['a' => 1, 'b' => 2, 'result' => 3],
        ['a' => 2, 'b' => 1, 'result' => 3],
        ['a' => 0, 'b' => 1, 'result' => 1],
        ['a' => 1, 'b' => 0, 'result' => 1],
    ];
}
                    </code></pre>
                    </section>

                    <section>
                        <p class="left_align">
                            20. Use continuous integration server
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Testing Facts</h2>
                        <p class="fragment left_align">
                            Once you start testing You wont want to write code without tests again
                        </p>
                        <p class="fragment left_align">
                            You are not good developer if you are not good tester
                        </p>
                        <p class="fragment left_align">
                            Quality is everyone’s responsibility — especially ours - developer’s.
                        </p>
                        <p class="fragment left_align">
                            Testing is fun :-)
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/testimony/phpunit_documentation.jpg">
                        </p>
                    </section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/testimony/test_driven_development_by_example.jpg">
                        </p>
                    </section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/testimony/laravel_testing_decoded.jpg">
                        </p>
                    </section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/testimony/the_art_of_unit_testing.png">
                        </p>
                    </section>
                </section>
				<section>
                    <section>
                        <h2>Resources</h2>
                        <ul>
                            <li><a href="http://www.slideshare.net/damiansromek/php-tests-tips">Php tests tips</a></li>
                            <li><a href="http://www.slideshare.net/ChonlasithJucksripor/unit-test-39809217">Unit test prez</a></li>
                            <li><a href="http://blog.typemock.com/2009/03/the-cost-of-test-driven-development.html">Cost of tdd</a></li>
                            <li><a href="https://vimeo.com/63492364">Sebastian Bergmann in Atlanta</a></li>
                            <li><a href="https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing">F.I.R.S.T Principles of Unit Testing</a></li>
                            <li><a href="http://agileinaflash.blogspot.de/2009/02/first.html">First principles</a></li>
                            <li><a href="https://pragprog.com/magazines/2012-01/unit-tests-are-first">Prag prog blog</a></li>
                            <li><a href="http://sqa.fyicenter.com/FAQ/JUnit/How_Often_Should_You_Run_Your_JUnit_Tests_.html">How Often Should You Run Your JUnit Tests?</a></li>
                            <li><a href="http://www.daedtech.com/">Daed blog</a></li>
                            <li><a href="https://developer.salesforce.com/page/How_to_Write_Good_Unit_Tests/">Salesforce blog</a></li>
                            <li><a href="http://googletesting.blogspot.co.uk/2015/04/just-say-no-to-more-end-to-end-tests.html">Google testing blog</a></li>
                            <li><a href="http://less.works/less/technical-excellence/unit-testing.html">Unit testing blog</a></li>
                            <li><a href="http://techportal.inviqa.com/2013/07/23/php-test-doubles-patterns-with-prophecy/">Testing doubles</a></li>
                            <li><a href="http://www.martinfowler.com/bliki/Xunit.html">Martin Fowler about XUnit</a></li>
                            <li><a href="http://createopen.com/design/php/2014/10/30/designing-through-mocking.html">Notes on designing through mocking</a></li>
                        </ul>
                    </section>
                    <section>
                        <h2>Images</h2>
                        <ul>
                            <li><a href="https://image-store.slidesharecdn.com/ebe9e374-6d3e-4f1a-8051-9591ef7ea7a3-original.jpeg">We are busy</a></li>
                            <li><a href="http://postd.cc/wp/wp-content/uploads/2014/07/vagrant_docker.png">Vagrant & Docker</a></li>
                            <li><a href="http://lh3.ggpht.com/-X8LPVvE5BYE/UHaLknLmMmI/AAAAAAAABg0/HDu3iZAs2yg/s1600-h/image7.png">TDD lifecycle</a></li>
                            <li><a href="http://quotespics.com/wp-content/quote-images/i-dont-always-test-my-code.jpg">Testing code in production</a></li>
                            <li><a href="http://financialjuneteenth.com/wp-content/uploads/2015/02/hard-work.jpg">Hard work</a></li>
                            <li><a href="https://www.dashingd3js.com/assets/steep_learning_curve-7c6e27560aabbd16a3ddb4eca06fe2fb.jpg">Steep learning curve</a></li>
                            <li><a href="https://cdn.psychologytoday.com/files/u570/5%3A25%3A10%20Getting%20Advice.jpg">Advice</a></li>
                            <li><a href="http://toptradersunplugged.com/wp-content/uploads/2015/05/TrueFalse2.jpeg">True or false</a></li>
                            <li><a href="http://2.bp.blogspot.com/-YTzv_O4TnkA/VTgexlumP1I/AAAAAAAAAJ8/57-rnwyvP6g/s1600/image02.png">Testing pyramid</a></li>
                            <li><a href="http://magentys.io/wp-content/uploads/2015/07/inverted-pyramid.png">Inverted Testing pyramid</a></li>
                            <li><a href="http://www.getautoma.com/img/blog/test_hour_glass.png">Hourglass</a></li>
                            <li><a href="https://s3-us-west-2.amazonaws.com/lysender.junk/uploads/2010/02/kohana-phpunit-001-crop.jpg">Kohana testing structure</a></li>
                        </ul>
                    </section>
				</section>

				<section>
					<h1>THANK YOU</h1>
				</section>

				<section>
					<h1>QUESTIONS?</h1>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>