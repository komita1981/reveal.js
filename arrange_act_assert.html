<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Testimony</title>

		<meta name="description" content="Keynote on testing">
		<meta name="author" content="Milan Popovic">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/presentation/arrange_act_assert.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
                    <p class="left_align">
                        What is main property of bad code?
                    </p>
                    <h2 class="fragment">
                        <span class="red_text">
                            It's untestable
                        </span>
                    </h2>
                </section>
                <section>
                    <h2>Kent Beck's rules of simple code</h2>

                    <ul>
                        <ol>
                            1. Runs all the tests
                        </ol>
                        <ol>
                            2. Contains no duplication
                        </ol>
                        <ol>
                            3. Express the intent of programmer
                        </ol>
                        <ol>
                            4. Minimizes the number of classes and methods
                        </ol>
                    </ul>

                    <p class="fragment red_text">
                        Given in order of importance
                    </p>

                    <aside class="notes">
                        Kent also said in his book TDD by example:
                        "No software engineers release even the tiniest change without testing, except the very
                        confident and the very sloppy"
                    </aside>
                </section>
                <section>
                    <p class="left_align">
                        &ldquo;
                        <q>
                            The degree to which you know how your software behaves is the degree to which you have
                            accurately tested it.
                        </q>
                        &rdquo; - Max Kanat-Alexander
                    </p>

                </section>
				<section>
					<h1>Arrange Act Assert</h1>
					<p>
						<small>Presented by <a href="http://milanpopovic.me">Milan Popović</a> / <a href="http://twitter.com/komita1981">@komita1981</a></small>
					</p>
				</section>

                <section>
                    <h2>Me</h2>
                    <p class="left_align">
                        PHP developer
                    </p>
                    <p class="left_align">
                        Work for Navus Consulting
                    </p>
                    <p class="left_align">
                        I like to learn and share knowledge
                    </p>
                    <p class="left_align">
                        Active member of PHP Srbija
                    </p>
                </section>

                <section>
                    <h2>What is testing?</h2>
                    <p class="fragment">
                        Testing is the activity of finding out whether a piece of code produces the intended behavior
                    </p>
                </section>

                <section>
                    <section>
                        <h2>What do people think about testing?</h2>
                    </section>

                    <section>
                        <img class="noframes" src="img/arrange_act_assert/i-dont-always-test-my-code.jpg">
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/arrange_act_assert/code_without_tests.jpeg">
                        </p>
                        <aside class="notes">
                            Time consuming - Who has time to write tests???
                        </aside>
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/arrange_act_assert/hard-work.jpg" height="600px" width="790px">
                        </p>
                        <aside class="notes">
                            Testing is hard
                        </aside>
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/arrange_act_assert/steep_learning_curve.jpg">
                        </p>
                        <aside class="notes">
                            Steep learning curve
                        </aside>
                    </section>

                    <section>
                        <p>
                            <img class="noframes" src="img/arrange_act_assert/no-money.jpg">
                        </p>
                        <aside class="notes">
                            Don’t make anybody any money
                        </aside>
                    </section>

                    <section>
                        <p class="left_align">
                            Time consuming
                        </p>
                        <p class="left_align">
                            Testing is hard
                        </p>
                        <p class="left_align">
                            Steep learning curve
                        </p>
                        <p class="left_align">
                            Don’t make anybody any money
                        </p>
                    </section>
                </section>

                <section>
                    <h2>What testing really is?</h2>

                    <p class="fragment left_align">
                        Prove you've done your work
                    </p>

                    <p class="fragment left_align">
                        Reduce number of bugs
                    </p>

                    <p class="fragment left_align">
                        Facilitate change
                    </p>

                    <p class="fragment left_align">
                        Help you make better code design - easier to maintain
                    </p>

                    <p class="fragment left_align">
                        Ensures stable, long lasting application
                    </p>

                    <p class="fragment left_align">
                        Improve understanding how clients are going to use your code
                    </p>

                    <p class="fragment left_align">
                        Enhance security
                    </p>

                    <p class="fragment left_align">
                        Provide free documentation
                    </p>

                    <aside class="notes">
                        Prove you've done your work - Help you check much faster if you're work is done. Testing is an
                        insurance that the system works.<br/><br/>

                        Facilitates change - protect you from breaking things - guard from regression bugs. Let you apply
                        changes with less worries - refactoring will improve things without breaking anything.<br/><br/>

                        Reduce number of bugs - Having a bug in the code means carrying a
                        risk. Utilising a set of unit tests, engineers can dramatically reduce number of bugs and the
                        risk with untested code - It better for you that you find your bugs than your client.
                    </aside>
                </section>

                <section>
                    <h2>Automated testing</h2>
                    <p class="red_text left_align">
                        When I say testing I mean AUTOMATED testing
                    </p>

                    <p class="left_align">
                        Automated testing is fun and a key point for software quality
                    </p>
                </section>

                <section>
                    <h2>Manual Testing</h2>
                    <p class="left_align">
                        Time consuming
                    </p>
                    <p class="left_align">
                        Slow
                    </p>
                    <p class="left_align">
                        Expensive
                    </p>
                    <p class="left_align">
                        Unreliable
                    </p>
                    <p class="left_align">
                        Boring
                    </p>
                </section>

                <section>
                    <blockquote style="width:100%; font-size: 1.4em;">
                        Take away my <span class="fragment fade-out">people</span>,
                        but leave my <span class="fragment fade-out">factories</span>,
                        and soon <span class="fragment fade-out">grass will grow on the factory floors</span>.<br />
                        Take away my <span class="fragment fade-out">factories</span>, but leave my <span class="fragment fade-out">people</span>, and soon we will have a new and better <span class="fragment fade-out">factory</span>.
                        <div style="text-align: right;">- Andrew Carnegie</div>
                    </blockquote>
                </section>
                <section style="font-size: 1.7em;">
                    Take away my <span class="fragment fade-in">test suites</span>,
                    but leave my <span class="fragment fade-in">source code</span>,
                    and soon <span class="fragment fade-in">the codebase will be expensive and bitrotten</span>.<br />
                    Take away my <span class="fragment fade-in">source code</span>,
                    but leave my <span class="fragment fade-in">test suites</span>,
                    and soon we will have a new and better <span class="fragment fade-in">codebase</span>.
                </section>

                <section>
                    <section>
                        <h2>Test types</h2>
                        <p class="fragment">
                            Acceptance (end-to-end)<br/>
                            Test as if end user would use the whole system/feature
                        </p>
                        <p class="fragment">
                            Integration<br/>
                            Test how different parts of system work together
                        </p>
                        <p class="fragment">
                            Unit<br/>
                            Test single unit of code - mock all dependencies
                        </p>
                        <aside class="notes">
                            Acceptance tests will help you to sell your code, unit tests will help you to maintain your
                            code.
                            Good ideas often fail in practice, and in the world of testing, one pervasive good idea that
                            often fails in practice is a testing strategy built around end-to-end tests.

                            Unit tests do have one major disadvantage: even if the units work well in isolation, you do
                            not know if they work well together. But even then, you do not necessarily need end-to-end
                            tests. For that, you can use an integration test. An integration test takes a small group
                            of units, often two units, and tests their behavior as a whole, verifying that they
                            coherently work together. If two units do not integrate properly, why write an end-to-end
                            test when you can write a much smaller, more focused integration test that will detect the
                            same bug? While you do need to think larger, you only need to think a little larger to
                            verify that units work together.
                        </aside>
                    </section>
                    <section>
                        <img class="noframes" src="img/arrange_act_assert/testing_pyramid.png">
                        <p class="left_align">
                            The higher we go - fewer number of tests, slower feedback, higher cost
                        </p>
                        <aside class="notes">
                            Width = Number of tests
                            The bulk of your tests are unit tests at the bottom of the pyramid. As you move up the
                            pyramid, your tests gets larger, but at the same time the number of tests (the width of your
                            pyramid) gets smaller.
                        </aside>
                    </section>
                    <section>
                        <h2>Google team suggest</h2>
                        <ul>
                            <li>
                                E2E - 10 %
                            </li>
                            <li>
                                Integration - 20%
                            </li>
                            <li>
                                Unit - 70%
                            </li>
                        </ul>
                        <aside class="notes">
                            As a good first guess, Google often suggests a 70/20/10 split:
                            70% unit tests, 20% integration tests, and 10% end-to-end tests. The exact mix will be
                            different for each team, but in general, it should retain that pyramid shape
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>
                            What is unit testing?
                        </h2>
                    </section>
                    <section>
                        <p class="left_align">
                            &ldquo;
                            <q>
                                A unit test is a piece of a code (usually a method) that invokes another piece of code and
                                checks the correctness of some assumptions after- ward. If the assumptions turn out to be wrong,
                                the unit test has failed. A unit is a method or function.                            </q>
                            &rdquo; - Roy Osherove
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            A software testing method to test individual unit of source code - a method in class or a piece of code
                        </p>
                        <p class="fragment left_align">
                            The purpose of unit testing is not for finding bugs
                        </p>
                        <p class="fragment left_align">
                            Specification for the expected behaviours of the code under test
                        </p>
                        <aside class="notes">
                            When writing unit tests we are focusing on describing one unit of behaviour at a time, and how
                            objects communicate in order to achieve that behaviour.

                            Each unit test sends a specific input to a method and verifies that the method returns the
                            expected value, or takes the expected action. Unit tests prove that the code you are testing
                            does in fact do what you expect it to do.

                            The purpose of unit testing is not for finding bugs. It’s a specification for the expected
                            behaviours of the code under test. The code under test is the implementation for those expected
                            behaviours. So unit test and the code under test are used to check the correctness of each other,
                            and protect each other. Later when someone changed the code under test, and it changed the
                            behaviour that is expected by the original author, the test will fail. If you code is covered by
                            reasonable unit test, you can maintain the code without breaking the existing feature.
                            That’s why Michael Feathers define legacy code as code without unit test.
                        </aside>
                    </section>

                    <section>
                        <h2>3 A of Unit testing</h2>
                        <p class="left_align">
                            <span class="red_text">A</span>rrange objects, creating and setting them up as necessary.
                        </p>
                        <p class="left_align">
                            <span class="red_text">A</span>ct on an object
                        </p>
                        <p class="left_align">
                            <span class="red_text">A</span>ssert that something is as expected
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            Arrange = Setup
                        </p>
                        <p class="left_align">
                            Act = Poke
                        </p>
                        <p class="left_align">
                            Assert = Verify
                        </p>

                        <aside class="notes">
                            Meszaros adds one more element - teardown (cleanup)

                            Bill Wake coined this as 3 A - TDD by example book
                        </aside>
                    </section>
                <section>
                    <pre><code data-trim contenteditable>
public function testSuccessful()
{
    // ARRANGE
    $d = $this->prophesize('\SomeNamespace\SomePackage\SomeDriverInterface');
    $driver->doSomething()->shouldBeCalled()->willReturn('value');
    $testedClass = new TestedClass($driver);

    // ACT
    $testResult = $testedClass->testedMethod();

    // ASSERT
    $this->assertSomething($expectedResult, $testResult);
}
                    </code></pre>
                </section>

                <section>
                    <h2>
                        Write unit tests before or after code?
                    </h2>
                    <p class="fragment left_align">
                        After - You test what you code - Test Last <br/>
                        Development Driven Testing - <span class="red_text">DDT</span>
                    </p>
                    <p class="fragment left_align">
                        Before - You code what you test - Test First<br/>
                        Test Driven Development - <span class="red_text">TDD</span>
                    </p>

                </section>

                <section>
                    <img class="noframes" src="img/arrange_act_assert/ddt_circle_of_life.png">

                    <aside class="notes">
                        Test Last = Test-After Development (TAD)
                        TAD programmers want to verify their code, too, but they typically have little interest in
                        treating the tests as “specifications by example.” For them, the usually singular goal of unit
                        testing is to verify whether or not some aspects of the code work. These unit tests typically
                        cover up to two-thirds of the code base. Other forms of integration tests can increase effective
                        coverage, but unit tests are the closest reliable documentation for the code you’re modifying.
                        The real sticking point with TAD is productivity. When you don’t think about how to craft code
                        so it’s testable, you’ll often end up with code that is near-impossible to test. The test-writer
                        has to either rework it or use a lot of finesse to avoid rework. This makes testing feel like a
                        waste of time. No wonder so few programmers have fully embraced unit-testing! We find TAD to be
                        simply less fun, less beneficial, less productive, and more frustrating than TDD.
                    </aside>

                </section>

                <section>
                    <h2>
                        The Three Laws of TDD
                    </h2>

                    <ol>
                        <li>
                            You may not write production code until you have written a failing unit test
                        </li>
                        <li>
                            You may not write more of a unit test than is sufficient to fail
                        </li>
                        <li>
                            You may not write more production code than is sufficient to pass the currently failing
                            test
                        </li>
                    </ol>
                </section>

                <section>
                    <img class="noframes" src="img/arrange_act_assert/tdd_circle_of_life.png">

                    <aside class="notes">
                        With TDD, every line of code has a reason to exist, with tests to back it up.

                        Only write code if you absolutely have to and always know what your code is supposed to do before
                        you start writing it - and that is what TDD approach provides for you

                        “Red-Green-Refactor,” meaning that you start with a failing test, then pass it, and then make
                        your code readable and more maintainable.
                    </aside>
                </section>

                <section>
                    <p>
                        <img class="noframes" src="img/arrange_act_assert/test_statistics.png">
                    </p>
                    <p>
                        IBM & Microsoft - TDD -  20-40% longer to complete but 40-90% fewer bugs in production
                    </p>
                </section>

                <section>
                    <blockquote>
                        By 2022 it will be not be possible to get a professional programming job if you do not practice
                        TDD routinely - Allan Kelly
                    </blockquote>
                </section>
                </section>

                <section>
                    <section>
                        <h2>Testing doubles</h2>
                        <ul>
                            <li class="left_align">Dummy</li>
                            <li class="left_align">Fake</li>
                            <li class="left_align">Stub</li>
                            <li class="left_align">Mock</li>
                            <li class="left_align">Spy</li>
                        </ul>
                        <aside class="notes">
                            Test doubles are a way of replacing all classes in our tests other than the one we are
                            testing. They give us control on direct and indirect outputs that would have been generated
                            by those classes. Understanding the role of the test double helps us to write better tests,
                            and thus better code. If we manage to isolate the “collaborators” (the other objects
                            involved in our test) using doubles and test our objects in isolation, then we have achieved
                            modularity: our code is decoupled and the communication between objects is documented by our
                            tests.

                            I prefer expectations when test-driving new behavior, because they keep my design honest;
                            but spies when rescuing legacy code, because I already know that the design is terrible.
                            J. B. Rainsberger
                        </aside>
                    </section>

                    <section>
                        <h2>Dummy</h2>
                        <p class="left_align">
                            Objects are passed around but never actually used
                        </p>
                        <p class="left_align">
                            Passed around for typehinting
                        </p>
                        <p class="left_align">
                            No behaviour
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
class CustomerCardPrinter
{
    private $printer;
    private $customer;

    public function __construct(PrinterInterface $printer, CustomerInterface $customer)
    {
        $this->printer = $printer;
        $this->customer = $customer;
    }

    public function print()
    {
        if (! $this->printer->isAvailable()){
            return false;
        }
        $customerName = $customer->getName();
        // some code goes here
    }
}

class CustomerCardPrinterTest
{
    public function testPrinterNotAvailable()
    {
        $printer = $this->prophesize('\SomeNamespace\SomePackage\PrinterInterface');
        
        $printer->isAvailable()->willReturn(false);

        $customer = $this->prophesize('\SomeNamespace\SomeOtherPackage\CustomerInterface');

        $customerCardPrinter = new CustomerCardPrinter($printer->reveal(), $customer->reveal());

        $printResult = $customerCardPrinter->print();

        $this->assertFalse($testResult);
    }
}
                        </code></pre>
                    </section>

                    <section>
                        <h2>Fake</h2>
                        <p class="left_align">
                            The output of the method isn’t important
                        </p>
                        <pre><code data-trim contenteditable>
interface PrinterInterface
{
    public function isAvailable();
}
class Printer implements PrinterInterface
{
    public function isAvailable()
    {
        // some code goes here
    }
}

class FakePrinter implements PrinterInterface
{
    public function isAvailable()
    {
        return true;
    }
}
                        </code></pre>

                    </section>

                    <section>
                        <h2>Stub</h2>
                        <p class="left_align">
                            Has (basic) behaviour but no expectations
                        </p>
                        <p class="left_align">
                            It does not matter how many times a method is called - Doesn't have to be called
                        </p>
                        <p class="left_align">
                            Promises it will always return the same thing (willReturn())
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
class CustomerCardPrinter
{
    private $printer;
    private $customer;

    public function __construct(PrinterInterface $printer, CustomerInterface $customer)
    {
        $this->printer = $printer;
        $this->customer = $customer;
    }

    public function print()
    {
        if (! $this->printer->isAvailable()){
            return false;
        }

        $customerName = $customer->getName();
        // some code goes here
    }
}

class CustomerCardPrinterTest
{
    public function testSuccessfulPrint()
    {
        $printer = $this->prophesize('\SomeNamespace\SomePackage\PrinterInterface');
        $printer->isAvailable()->willReturn(true);

        $customer = $this->prophesize('\SomeNamespace\SomeOtherPackage\CustomerInterface');
        $customer->getName()->willReturn('SomeName');

        $customerCardPrinter = new CustomerCardPrinter($someDriver->reveal(), $dummyPrinter->reveal());

        $printResult = $customerCardPrinter->print();

        $this->assertTrue($expectedResult, $testResult);
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Mock</h2>
                        <p class="left_align">
                            Define predictions (shouldBeCalled()), not promises
                        </p>
                        <p class="left_align">
                            Describing what will happen in the future
                        </p>
                        <p class="left_align">
                            Keeps track of method calls and their arguments
                        </p>
                        <p class="left_align">
                            Validates method calls given a certain set of expectations
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
class CustomerCardPrinter
{
    private $printer;
    private $customer;

    public function __construct(PrinterInterface $printer, CustomerInterface $customer)
    {
        $this->printer = $printer;
        $this->customer = $customer;
    }

    public function print()
    {
        if (! $this->printer->isAvailable()){
            return false;
        }

        $customerName = $customer->getName();
        // some code goes here
    }
}

class CustomerCardPrinterTest
{
    public function testSuccessfulPrint()
    {
        $printer = $this->prophesize('\SomeNamespace\SomePackage\PrinterInterface');
        $printer->isAvailable()->shouldBeCalled()->willReturn(true);

        $customer = $this->prophesize('\SomeNamespace\SomeOtherPackage\CustomerInterface');
        $customer->getName()->shouldBeCalled()->willReturn('SomeName');

        $customerCardPrinter = new CustomerCardPrinter($someDriver->reveal(), $dummyPrinter->reveal());

        $printResult = $customerCardPrinter->print();

        $this->assertTrue($expectedResult, $testResult);
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Spy</h2>
                        <p class="left_align">
                            Records behaviour
                        </p>
                        <p class="left_align">
                            Describing what has happened in the past
                        </p>
                        <p class="left_align">
                            Assertions happen afterwards (shouldHaveBeenCalled())
                        </p>
                    </section>
                    <section>
                        <pre><code data-trim contenteditable>
function it_notifies_an_attached_subscriber()
{
    // arrange
    $parser = new ParserSubject;

    $event = $this->prophesize('Markdown\Event\Event')->reveal();
    $subscriber = $this->prophesize('Markdown\Parser\Subscriber')->reveal();

    // act
    $parser->notify($event);

    // assert
    $subscriber->onChange($event)->shouldHaveBeenCalled();
}
                        </code></pre>
                    </section>

                </section>

                <section>
                    <section>
                        <img class="noframes" src="img/arrange_act_assert/advice.jpg">
                    </section>
                    <section>
                        <p class="left_align">
                            1. Try with writing tests after writing the code
                        <p class="left_align">
                    </section>
                    <section>
                        <p class="left_align">
                            2. When you get confidence try to write tests before the code
                        <p class="left_align">
                    </section>
                    <section>
                        <p class="left_align">
                            3. Treat test like your code - keep it "clean"
                        <p class="left_align">
                        <p class="fragment">
                            <ul>
                                <li>
                                    Be descriptive about what you are testing
                                </li>
                                <li>
                                    Do not duplicate test code
                                </li>
                                <li>
                                    Do not make tests complex
                                </li>
                            </ul>
                        </p>
                        <aside class="notes">
                            Tests are clean if they are readable. What make them readable is clarity, simplicity and
                            density of expression - Clean Code - Robert C Martin
                            "What makes a clean test? Three things - Readability, readability, readability
                            Readability is even more important than in production code

                            Keep in mind that testing code is important as production code - maybe more important. It must
                            be clean as production code. Code changes and that means that your tests also changes - if you
                            write them bad than you have big problem - double problem. You are not safe anymore. You will start
                            writing code without tests.

                            Unit tests keep our code flexible, maintainable and reusable. Without them we loose everything.
                            With good tests we can improve architecture and design without having the fear of introducing
                            bugs.
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            4. Number of asserts in a test ought to be minimized
                        </p>
                        <aside class="notes">
                            One assert per test story...
                            Better use Single Concept per Test
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            5. Use Virtual Environments
                        </p>
                        <p class="left_align">
                            <img class="noframes" src="img/arrange_act_assert/vagrant_docker.png">
                        </p>
                        <aside class="notes">
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            6. Run tests often
                        </p>
                        <aside class="notes">
                            Run all your unit tests as often as possible, ideally every time the code is changed and
                            before any commit. Running tests often gives you confidence that your changes didn't break
                            anything and generally lowers the stress of programming in the dark. For larger systems,
                            you may just run specific test suites that are relevant to the code you're working on. Run
                            all your acceptance, integration, stress, and unit tests at least once per day (or night).
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            7. Test Boundary Conditions
                        </p>
                        <aside class="notes">
                            Take care about testing boundary values
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            8. Use test saboteurs (Humbug project)
                        </p>
                        <aside class="notes">
                            Mutation Testing is, in a nutshell, giving your unit tests a run for their money. It
                            involves injecting small defects into source code and then checking if the unit tests
                            noticed. If they do, then your unit tests have "killed" the mutation. If not, the mutation
                            has escaped detection. As unit tests are intended to prevent regressions, having a real
                            regression pass unnoticed would be a bad thing! Whereas Code Coverage can tell you what code
                            your tests are executing, Mutation Testing is intended to help you judge how well your unit
                            tests actually perform and where they could be improved.
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                            9. Use test coverage
                        </p>
                        <p class="left_align">
                            <img class="noframes" src="img/arrange_act_assert/code-coverage.png">
                        </p>

                        <aside class="notes">
                            The higher code coverage makes your confidence also high - less fear of change
                        </aside>
                    </section>

                    <section>
                        <p class="red_text">
                            Test branch coverage not only code coverage
                        <pre><code data-trim contenteditable>
sampleMethod()
{
    if (a < 5 and b > 10){
       return a + b;
    }

    return $a - $b;
}
                        </code></pre>
                        </p>

                    </section>
                    <section>
                        <p class="left_align">
                            10. Test before refactoring
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            11. Write unit tests for each bug you are going to fix
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            12. Think twice before using New Operators - new ClassName()
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            13. Think twice before using statics - SomeClass::someMethod()
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            14. Avoid endless "anding" - Breaking SRP
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            15. Avoid using switch-case often - use design patterns instead
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            16. Avoid using too many dependencies - max 4 dependencies
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            17. Avoid logic in constructor - only assign variables
                        </p>
                    </section>
                    <section>
                        <p class="left_align">
                            17. Do not break Law of Demeter
                        </p>
                        <pre><code data-trim contenteditable>
if ($account->getUser()->getRole()->IsAdmin()) {
    return false;
}
                        </code></pre>
                    </section>
                    <section>
                        <p class="left_align">
                           18. Do Not Mock What You Do not Own
                        </p>

                        <aside class="notes">
                            Wrap 3rd party.
                            A framework or third party object often has to provide a large interface to solve a large
                            number of needs, of which you only need a subset. When you write your wrapper don't try and
                            write everything it does, write the operations you need, with the interface you want. If
                            you're using the language of your domain, rather than the language of the third party object,
                            this is much simpler.
                        </aside>
                    </section>
                    <section>
                        <p class="left_align">
                           19. Use data providers
                        </p>
                        <pre><code data-trim contenteditable>
/**
* @dataProvider getSuccessfulAddData
*/
public function testSuccessfulAdd($a, $b, $result)
{
    $this->assertEquals($result,
    $this->calculator->add($a, $b));
}

public function getSuccessfulAddData()
{
    return [
        ['a' => 1, 'b' => 2, 'result' => 3],
        ['a' => 2, 'b' => 1, 'result' => 3],
        ['a' => 0, 'b' => 1, 'result' => 1],
        ['a' => 1, 'b' => 0, 'result' => 1],
    ];
}
                    </code></pre>
                    </section>

                    <section>
                        <p class="left_align">
                            20. Use continuous integration server
                        </p>
                    </section>

                    <section>
                        <p>
                            21.
                            <img class="noframes" src="img/arrange_act_assert/unit-testing-mvc.png">
                        </p>
                    </section>

                    <section>
                        <p class="left_align">
                            22. Programming by Wishful Thinking
                        </p>

                        <aside class="notes">
                            Write some code that uses a component, before you implement the component. This helps to
                            discover what functions and data you need, and following this discovery will lead you to more
                            simple and useful APIs.
                            I write acceptance tests using a fixture I wish I had, and then implement the feature using
                            collaborators I wish I had.
                            Defer the decision about how to represent your data by imagining you have any function you
                            wish you had in order to solve your problem in the simplest way possible.
                        </aside>
                    </section>

                    <section>
                        <p class="left_align">
                            23. Allow queries expect commands
                        </p>

                        <aside class="notes">
                            Commands should be mocked - queries should be stubbed
                        </aside>
                    </section>

                    <section>
                        <p class="left_align">
                            24. Before asserting through loop use assertCount
                        </p>

                        <aside class="notes">
                            Foreach on empty will assert nothing and we will have false positive test
                        </aside>

                    </section>

                    <section>
                        <p class="left_align">
                            25. Mock Interfaces Not Implementations
                        </p>

                    </section>
                </section>

                <section>
                    <section>
                        <img height="680" class="noframes" src="img/arrange_act_assert/facts.gif">
                    </section>

                    <section>
                        <p class="left_align">
                            Once you start testing You wont want to write code without tests again
                        </p>
                        <p class="fragment left_align">
                            You are not good developer if you are not good tester
                        </p>
                        <p class="fragment left_align">
                            Writing code that is testable encourages best practices - such as SOLID
                        </p>
                        <p class="fragment left_align">
                            Quality is everyone’s responsibility — especially ours - developer’s
                        </p>
                        <p class="fragment left_align">
                            Testing is fun :-)
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <img height="680" class="noframes" src="img/testimony/facts.gif">
                    </section>

                    <section>
                        <p class="left_align">
                            Once you start testing You wont want to write code without tests again
                        </p>
                        <p class="fragment left_align">
                            You are not good developer if you are not good tester
                        </p>
                        <p class="fragment left_align">
                            Writing code that is testable encourages best practices - such as SOLID
                        </p>
                        <p class="fragment left_align">
                            Quality is everyone’s responsibility — especially ours - developer’s
                        </p>
                        <p class="fragment left_align">
                            Testing is fun :-)
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/arrange_act_assert/phpunit_documentation.jpg">
                        </p>
                    </section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/arrange_act_assert/test_driven_development_by_example.jpg">
                        </p>
                    </section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/arrange_act_assert/laravel_testing_decoded.jpg">
                        </p>
                    </section>
                    <section>
                        <p>
                            <img height="680" class="noframes" src="img/arrange_act_assert/the_art_of_unit_testing.png">
                        </p>
                    </section>
                </section>
				<section>
                    <section>
                        <h2>Resources</h2>
                        <ul>
                            <li><a href="http://www.slideshare.net/damiansromek/php-tests-tips">Php tests tips</a></li>
                            <li><a href="http://www.slideshare.net/ChonlasithJucksripor/unit-test-39809217">Unit test prez</a></li>
                            <li><a href="http://blog.typemock.com/2009/03/the-cost-of-test-driven-development.html">Cost of tdd</a></li>
                            <li><a href="https://vimeo.com/63492364">Sebastian Bergmann in Atlanta</a></li>
                            <li><a href="https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing">F.I.R.S.T Principles of Unit Testing</a></li>
                            <li><a href="http://agileinaflash.blogspot.de/2009/02/first.html">First principles</a></li>
                            <li><a href="https://pragprog.com/magazines/2012-01/unit-tests-are-first">Prag prog blog</a></li>
                            <li><a href="http://sqa.fyicenter.com/FAQ/JUnit/How_Often_Should_You_Run_Your_JUnit_Tests_.html">How Often Should You Run Your JUnit Tests?</a></li>
                            <li><a href="http://www.daedtech.com/">Daed blog</a></li>
                            <li><a href="https://developer.salesforce.com/page/How_to_Write_Good_Unit_Tests/">Salesforce blog</a></li>
                            <li><a href="http://googletesting.blogspot.co.uk/2015/04/just-say-no-to-more-end-to-end-tests.html">Google testing blog</a></li>
                            <li><a href="http://less.works/less/technical-excellence/unit-testing.html">Unit testing blog</a></li>
                            <li><a href="http://techportal.inviqa.com/2013/07/23/php-test-doubles-patterns-with-prophecy/">Testing doubles</a></li>
                            <li><a href="http://www.martinfowler.com/bliki/Xunit.html">Martin Fowler about XUnit</a></li>
                            <li><a href="http://createopen.com/design/php/2014/10/30/designing-through-mocking.html">Notes on designing through mocking</a></li>
                            <li><a href="https://blog.thesoftwarecraft.com/2013/11/wishful-programming.html">Wishful Programming</a></li>
                            <li><a href="https://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html">That's Not Yours</a></li>
                            <li><a href="https://github.com/tklever/testing-and-you">Testing and you</a></li>
                        </ul>
                    </section>
                    <section>
                        <h2>Images</h2>
                        <ul>
                            <li><a href="https://image-store.slidesharecdn.com/ebe9e374-6d3e-4f1a-8051-9591ef7ea7a3-original.jpeg">We are busy</a></li>
                            <li><a href="http://postd.cc/wp/wp-content/uploads/2014/07/vagrant_docker.png">Vagrant & Docker</a></li>
                            <li><a href="http://lh3.ggpht.com/-X8LPVvE5BYE/UHaLknLmMmI/AAAAAAAABg0/HDu3iZAs2yg/s1600-h/image7.png">TDD lifecycle</a></li>
                            <li><a href="http://quotespics.com/wp-content/quote-images/i-dont-always-test-my-code.jpg">Testing code in production</a></li>
                            <li><a href="http://financialjuneteenth.com/wp-content/uploads/2015/02/hard-work.jpg">Hard work</a></li>
                            <li><a href="https://www.dashingd3js.com/assets/steep_learning_curve-7c6e27560aabbd16a3ddb4eca06fe2fb.jpg">Steep learning curve</a></li>
                            <li><a href="https://cdn.psychologytoday.com/files/u570/5%3A25%3A10%20Getting%20Advice.jpg">Advice</a></li>
                            <li><a href="http://toptradersunplugged.com/wp-content/uploads/2015/05/TrueFalse2.jpeg">True or false</a></li>
                            <li><a href="http://2.bp.blogspot.com/-YTzv_O4TnkA/VTgexlumP1I/AAAAAAAAAJ8/57-rnwyvP6g/s1600/image02.png">Testing pyramid</a></li>
                            <li><a href="http://magentys.io/wp-content/uploads/2015/07/inverted-pyramid.png">Inverted Testing pyramid</a></li>
                            <li><a href="http://www.getautoma.com/img/blog/test_hour_glass.png">Hourglass</a></li>
                            <li><a href="https://s3-us-west-2.amazonaws.com/lysender.junk/uploads/2010/02/kohana-phpunit-001-crop.jpg">Kohana testing structure</a></li>
                            <li><a href="http://www.kalispellchiropractic.com/wp-content/uploads/2015/02/chiropractic-images.gif">Facts</a></li>
                            <li><a href="http://www.adamtibi.net/wp-content/uploads/2013/06/unit-testing-mvc.png">Unit testing mvc</a></li>
                        </ul>
                    </section>
				</section>

				<section>
					<h1>THANK YOU</h1>
				</section>

				<section>
					<h1>QUESTIONS?</h1>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>